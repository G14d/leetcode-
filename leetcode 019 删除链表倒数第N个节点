//给定一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。

/*提示
链表中结点的数目为 sz
1 <= sz <= 30
0 <= Node.val <= 100
1 <= n <= sz
*/
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */

//我的理解
//第一步：遍历链表找出节点数目
//第二步：维护两个节点，根据给到的节点数目和要删除的第n个节点。开始循环递推：最后current节点会走到需要删除的节点，prev会到current的前一个
//第三步：使prev->next = current->next;并free（current）；

//遇到的问题：
/*第一：我给prev初始化为NULL,结果是，当我想要删除的节点正好是头节点的时候。我们的循环没有进行，current 和 prev 都是保持的初始化的状态(current = head；prev = NULL)
于是在最后当我想要进行   prev->next = current->next;实质上利用了NULL->next ,导致报错*/
/*修改的方法:进行了一次if判断
if(prev==NULL)
    {
        return head->next;
    }
如果想要删除的是头节点，那么我们干脆返回头节点的下一个节点作为头节点
*/


struct ListNode* removeNthFromEnd(struct ListNode* head, int n)
{
    struct ListNode* prev = NULL;
    struct ListNode* current = head;
    struct ListNode* test = head;//这个test就是我拿过来测试链表长度的节点
    int sz = 1
    if(head->next!=NULL)//提示中声明sz>=1所以我们直接判断下一个节点有没有
    {
        while(test->next!=NULL)
        {
            test = test->next;
            sz++;
        }
    }
    int i;
    for(i=0;i<sz-n;i++)//不删除头节点情况下递推
    {
        prev = current;
        current = current->next;
    }
    if(prev==NULL)//删除头节点情况下
    {
        return head->next;//直接返回下一个节点
    }
    prev->next = current->next;
    free(current);
    return head;

}

//leetcode题解
//设置哑节点
int getLength(struct ListNode* head)
{
    int length = 0;
    while (head) 
    {
        ++length;
        head = head->next;
    }
    return length;
}
//得出链表长度
struct ListNode* removeNthFromEnd(struct ListNode* head, int n) 
{
    struct ListNode* dummy = malloc(sizeof(struct ListNode));//申请哑节点
    dummy->val = 0, dummy->next = head;//初始化哑节点
    int length = getLength(head);//获取链表长度
    struct ListNode* cur = dummy;//设置当前节点指向哑节点
    for (int i = 1; i < length - n + 1; ++i) //通过该函数走向删除节点的前一个节点
    {
        cur = cur->next;
    }
    cur->next = cur->next->next;直接使用cur->next代表下一个节点，在利用->next获取下下个节点的首地址
    struct ListNode* ans = dummy->next;
    free(dummy);//释放哑节点
    return ans;
}
//这个方法引用新节点，避免了头插的判断，哑节点变成了头节点。剩下的算作普通节点

作者：力扣官方题解
链接：https://leetcode.cn/problems/remove-nth-node-from-end-of-list/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
